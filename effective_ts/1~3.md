## item1

- 모든 자바스크립트 프로그램이 타입스크립트라는 명제는 참이지만, 그 반대는 성립하지 않는다
- 타입 시스템의 목표 중 하나는 `런타임에 오류를 발생시킬 코드를 미리 찾아내는 것`
- 그러나 모든 오류를 찾아내리라 기대하면x 타입 체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있음을 명심

## item2

타입스크립트 컴파일러는 매우 많은 설정을 가지고 있다
(`tsconfig.json` 파일을 통해 설정 가능)

### 대표 권장 설정 목록

- `noImplicitAny`
  - **변수들이 미리 정의된 타입을 가져야 하는지 여부 제어**
  - 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 설정하는 것을 권장
  - 코드의 가독성이 좋아지며, 개발자의 생산성이 향상됨
  - `noImplicitAny` 해제는 자바스크립트로 되어 있는 기존 프로젝트를 타입스크립트로 전환하는 상황에만 필요
- `strictNullChecks`
  - null 과 undefined가 모든 타입에서 허용되는 지 확인하는 설정
  - null 과 undefined 관련된 오류를 잡아 내는 데 많은 도움이 되지만, 코드 작성을 다소 어렵게 만듦

## item3

### 타입스크립트 컴파일러의 두 가지 역할

1. 구버전의 자바스크립트로 트랜스파일(transpile)
2. 코드의 타입 오류 체크

### 타입 오류가 있는 코드도 컴파일이 가능하다

> 🗣️ 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능하다. 문제가 될 만한 부분을 알려 주지만, 그렇다고 build를 멈추지는 않는다
> (만약 오류가 있을 때 컴파일하지 않으려면, `noEmitOnError`를 설정)

### 런타임에는 타입 체크가 불가능하다

- 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 제거된다
- 타입 정보를 유지하는 방법으로는 일반적으로
  - 태그된 유니온과 속성 체크 방법
  - 또는 클래스로 만드는 방법 등이 있다

### 타입 연산은 런타임에 영향을 주지 않는다

- ex) `as number`는 타입 연산(타입 단언문)이며 런타임 동작에는 아무 영향을 미치지 않는다

### 런타임 타입은 선언된 타입과 다를 수 있다

- 예를 들어 네트워크 호출로부터 받아온 값으로 함수를 실행하는 경우나 배포된 이후 API가 변경되는 경우 등 **런타임 타입과 선언된 타입이 맞지 않을 수 있다는 것을 명심해야 한다**

### 타입스크립트 타입으로는 함수를 오버로드할 수 없다

> 🗣️ 동일한 이름에 매개변수만 다른 여러 버전의 함수를 허용하는 것을 `함수 오버로딩`이라 한다

- 타입스크립트에서는 타입과 런타임의 동작이 무관하기 때문에, 함수 오버로딩이 불가능하다
- 함수의 오버로딩 기능을 지원하긴 하지만 온전히 타입 수준에서만 동작하며, 여러 개의 함수 선언문을 작성할 수는 있지만 `구현체는 오직 하나뿐이다.`

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

> 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에, 런타임의 성능에 아무런 영향을 주지 않는다
